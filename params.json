{"name":"LN2D-Libraries","tagline":"Component-based game library for iOS/Mac","body":"LN2D-Libraries\r\n==============\r\n\r\n[LN2D](http://ln2d.lynnard.tk) is a library designed for anyone to easily create game objects/scenes for iOS/Mac.\r\n\r\n## Dependencies\r\n\r\n* [Cocos2D][cocos2d]: the base library containing the lower level code\r\n\r\n## Architecture\r\n\r\nLN2D uses a component-based architecture that makes intuitive sense in the following scenarios\r\n\r\n* hierarchical composition of multiple game objects\r\n* interfacing between models and views\r\n* dynamic addition/removing of *capabilities* from a game object\r\n    * each *capability* is realized via one or a set of components\r\n* reuse of existing components\r\n\r\nWhile the prevalent form of game architecture in the industry is still based on object hierarchies at the moment, component-based approaches are gathering more and more momentum due to the flexibility and dynamism afforded by such frameworks. Some of the notable ones include:\r\n\r\n* [cistron](http://code.google.com/p/cistron/)\r\n* [artemis](http://gamadu.com/artemis/)\r\n\r\n## Game object\r\n\r\nEach game object is composed of two parts\r\n\r\n1. a view (achieved via the native `CCNode` functionalities from [Cocos2D][cocos2d])\r\n2. a component hierarchy (`CCComponent`) for logic and model\r\n\r\nIn implementation, this is achieved by having a property of type `CCComponent` called `rootComponent` for each `CCNode`. So for example if you want to add a component to a given node:\r\n\r\n    [node.rootComponent addChild:someComponent];\r\n\r\n## CCComponent\r\n\r\nEach `CCComponent` can contain an infinite number of sub `CCComponent`s.\r\n\r\nEach of these sub-components can be *enabled/disabled* dynamically on the go by toggling its `enabled` property.\r\n\r\nNote that the library makes a distinction between *enabled* and *activated*:\r\n\r\n* when a component is enabled, it might not get activated\r\n    * an example is that a component depending on some sub-components won't be activated unless those sub-components are enabled and activated first\r\n* when it's disabled, it will definitely be deactivated\r\n\r\nYou can specify the exact condition for *activation* by overriding `activated` and also its dependencies by overriding the `keyPathsForValuesAffectingActivated` method.\r\n\r\n### Querying/adding/removing sub components\r\n\r\n#### Key interface\r\n\r\nAssociate a sub-component with a key. The old component associated with the key will be removed.\r\n\r\n    setChild:forKey:\r\n    childForKey:\r\n    removeChildForKey:\r\n\r\n#### Tag (number) interface\r\n\r\nAssociate a sub-component with a tag. The old component associated with the tag will be removed.\r\n\r\n    setChild:forTag:\r\n    childForTag:\r\n    removeChildForTag\r\n\r\n#### Class interface\r\n\r\nAssociate a sub-component with a `class`.  This is useful as it allows us to assign *responsibilities* for each sub-component. For example we can assign a subclass of `Body` component to the class `Body` to handle all physics related calculation concerning the body of a game object. A different subclass of `Body`, when added to the same object, is thus able to *replace* the old component handling the body calculation.\r\n\r\n    childForClass:\r\n    setChild:forClass:\r\n    setChild:forClassLock:\r\n\r\nNote: the `ClassLock` version removes all components matching the given class argument before adding the child and associate it with that class.\r\n\r\n#### Selector interface\r\n\r\nAssociate a sub-component with a `SEL`. Similar to before, this is useful for differentiating components by their responsibilities. In particular, this looks at what message the component responds to.\r\n\r\n    childForSelector:\r\n    setChild:forSelector:\r\n    setChild:forSelectorLock:\r\n\r\nAgain, the `Lock` version removes all components responding to the same message.\r\n\r\n#### General predicate interface\r\n\r\nIn fact, the [class interface](#class-interface) and [selector interface](#selector-interface) are just variants of the predicate interface. The predicate interface allows us to associate components with *an arbitrary predicate*, including *block*-based ones.\r\n\r\n    childForPredicate:\r\n    setChild:forPredicate:\r\n    setChild:forPredicateLock:\r\n\r\nTo make all these possible, the implementation makes use of a complex predicate caching mechanism to cache recent predicate queries and return results faster.\r\n\r\n### Life-cycle\r\n\r\n* `componentAdded`: determines what to do when the component is added into a component hierarchy\r\n* `componentRemoved`: triggered with the component is removed from a component hierarchy\r\n* `componentActivated`: triggered when the component is activated\r\n* `componentDeactivated`: triggered when the component is deactivated\r\n\r\nThe implementation uses Key Value Observing techniques to make sure that the dependencies specified by `keyPathsForValuesAffectingActivated` are monitored all the time and these methods are called (especially `componentActivated` and `componentDeactivated`) whenever the condition turns true/false.\r\n\r\n### Message passing\r\n\r\nBy default components can intercept messages sent to their masters. This happens when the master does not respond to a message, in which case the first component that responds to the message is selected as the receiver. \r\n\r\n### Components included in the library\r\n\r\n#### Physics\r\n\r\nLN2D provides a variety of physics environment for you to easily plug in to your game application.\r\n\r\nFor each physics environment, there is a dedicated `Body` component that should be attached to the objects which you wish to drive. The `Body` component defines the physical properties about the object, including mass, velocity, acceleration, etc. It might also have a `ContactListener` which triggers a function when it collides with certain objects (as informed by the physics environment).\r\n\r\nIn addition, you should also set up a `Space` component and attach it to the outermost node that contains all the physical objects with `Body`s. The `Body` component interacts with the `Space` component, gets the environmental properties, e.g., gravity, collision, relative positioning, and updates its master properly.\r\n\r\nBy using such a design, we are also able to localise the environments e.g., you can have an environment for one group of nodes, and another for some other group.\r\n\r\n##### Simple physics environment\r\n\r\n`TranslationalBody` provides the simplest implementation of a body. You can define its starting `position`, `velocity` and `acceleration`, and it will update the position of its master at every tick.\r\n\r\nIf you need simple gravity, you should attach a `PhysicsSpace` on the outermost node containing the nodes with `TranslationalBody`s. The `PhysicsSpace` will automatically search for the bodies and wire up the connections so that there is nothing more for you to do.\r\n\r\nIf you also need collision, you should replace the use of `TranslationalBody` with `MaskedBody`. Each `MaskedBody` is initialised with a `Mask` that defines the boundary of the object for collision checking by `PhysicsSpace`. You should also attach a `ContactListener` to the `MaskedBody`, which is just a simple wrap-up of functions to be called when the body makes a contact with another `MaskedBody`.\r\n\r\n###### Mask\r\n\r\nThere are a variety of masks (you can also write your own). The library comes with a number of them that should cater to most use cases.\r\n\r\n* `RectMask`: uses `CCNode`'s `boundingBox` as the mask\r\n* `PixelMask`: uses an image as the mask\r\n    * for each pixel, if it's above an `alphaThreshold` then it's considered a *solid* point that makes up the object\r\n    * these information is saved in a `PixelMaskData`, which transforms an image to a `BitMask` (the underlying data structure for fast intersection checking)\r\n    * for performance, the library provides a `MaskDataCache` that recycles the `PixelMaskData` so that the same image doesn't get processed twice (wasting CPU as well as storage)\r\n    * you initialize a `PixelMask` by asking the cache for the `PixelMaskData`; then you attach the `PixelMask` to the `MaskedBody`; the remaining will be automatically worked out by the system\r\n* `AutoPixelMask`: an even simpler alternative to `PixelMask`, `AutoPixelMask` attaches to the `MaskedBody` of a `CCSprite` and use the displaying sprite as the mask; you need to do nothing about setting up the mask anymore\r\n    * an added benefit is that whenever the `CCSprite` changes its displaying frame, the `AutoPixelMask` adjusts accordingly\r\n    * this is very useful for sprite animations\r\n\r\n##### Box2D environment\r\n\r\nLN2D provides a complete component interface of the [Box2D](http://box2d.org) physics engine.\r\n\r\nEach node to be managed should include a `B2DBody` component (objective-C wrapper of `b2Body`); it supports `B2DFixture` (wrapper of `b2Fixture`) and `B2DContactListener`.\r\n\r\nThe world container node should have a `B2DSpace` component (wrapper of `b2World`).\r\n\r\nIf you use [R.U.B.E.](https://www.iforce2d.net/rube/) to edit Box2D worlds, there is also `B2DRUBECache` for you to easily load RUBE generated json file into components.\r\n\r\nAn example usage is shown below\r\n\r\n        B2DRUBECache *cache = [B2DRUBECache cacheForSpace:space withFileName:@\"player.json\"];\r\n        cache.space.ptmRatio = 50;\r\n        [layer.rootComponent addChild:cache.space];\r\n        // add Box2D objects as CCNodes with loaded B2DBody components\r\n        [layer addChildren:[cache allBodyNodes]];\r\n\r\n\r\n#### Spawner\r\n\r\n`Spawner` is a component designed to simplify the logic concerning spawning and respawning certain game objects (e.g., enemies). It takes a `RandomPointGenerator` (a helper class that generates random points given a range/region) and simply moves its master to a random point generated by the `RandomPointGenerator` when its `spawn` method is called.\r\n\r\n#### Display\r\n\r\n##### Animator\r\n\r\n`Animator` is component that handles the task of animating a `CCSprite`. You can set animations with the method `setAnimation:forTag:repeatForever:restoreOriginal:`, and after that you can simply playback an animation by its tag i.e. `run:`.\r\n\r\n##### DisplayRandomizer\r\n\r\n`DisplayRandomizer` shuffles the sprite frame for a `CCSprite`. It taks a `RandomStringGenerator` that generates the name of the sprite frame that its master should display at random, and after that you can simply call its `setNextDisplayFrame` to shuffle the display frame of its master. This is useful for recycling sprites e.g., you can an enemy class with a few different appearances, you can spawn them at random using `Spawner` and set a random appearance with `DisplayRandomizer`.\r\n\r\n## Structure\r\n\r\nStructures are subclasses of `CCNode` that act as powerful metaphors for easily combining and creating advanced nodes from basic elements.\r\n\r\n### GridNode\r\n\r\nA `GridNode` is a node that holds a rectangular grid of sub `CCNode`s. With `GridNode` you can easily create tile maps, floors, etc.\r\n\r\nThe best thing about this structure is that it utilizes the *objective* feature of the language as much as possible. For example:\r\n\r\n```\r\nGridNode *grid = [GridNode gridWithGap:0];\r\ngrid.rows[0] = [GridLine lineWithWidth:50];\r\ngrid[0][0] = [CCSprite spriteAnchoredAtOriginWithSpriteFrameName:@\"backgroundLayer/bridge_flat_base1.png\"];\r\ngrid[1][0] = [CCSprite spriteAnchoredAtOriginWithSpriteFrameName:@\"backgroundLayer/bridge_flat_repeat1.png\"];\r\n[grid.rows[0] insertCell:[CCSprite spriteAnchoredAtOriginWithSpriteFrameName:@\"backgroundLayer/bridge_flat_repeat1.png\"] atIndex:0];\r\n[grid.cols addLine:grid.cols.cutFirst];\r\n```\r\nThe above demonstrates just a few things `GridNode` is capable of.\r\n\r\nSome points to note:\r\n\r\n* `grid[x][y]` points to a cell at `x`'th column and `y`'th row\r\n* `grid.rows[y]` represents the `y`'th row of the grid as a `GridLine` object with an interface similar to that of a `NSArray`\r\n    * you can add/insert/set/remove elements, and these changes propagate to the entire grid - columns are inserted/updated/removed when necessary, etc.\r\n* similarly, `grid.cols[x]` represents the `x`'th column as a `GridLine`\r\n\r\n### SpawnDispatcher\r\n\r\n`SpawnDispatcher` is a group of structures that manages spawn-able objects. \r\n\r\n#### PeriodicSpawnDispatcher\r\n\r\n`PeriodicSpawnDispatcher` periodically (with the period you specify) *spawns* its children with a tag equal to the specified value; here *spawn* means sending the children a message to respawn themselves (usually they have a `Spawner` component that will respond to the message).\r\n\r\n## Usage\r\n\r\nA typical usage of LN2D revolves around *compositing* the range of components. When a functionality does not yet exist in the component library, you should write a new `CCComponent` so that you can reuse the same functionality in the future.\r\n\r\nFor example, say I want to program a new `Player` object to represent the player in the game. I can composite it as `Animator`+`B2DBody` (of course adding `B2DSpace` to the outer container node).\r\n\r\nSimilarly, for an enemy class `Enemy`, I can composite it as `Animator`+`B2DBody`+`Spawner` and instantiate a number of its instances in a `SpawnDispatcher` to have a respawn-able, randomly changing, and recycled group of enemies.\r\n\r\n[cocos2d]: http://cocos2d.org/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}